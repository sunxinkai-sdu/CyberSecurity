## SM3的软件实现与优化
### 实现和优化SM3算法
#### SM3算法流程
* 消息填充：首先对输入的消息进行填充，使其长度变为512的倍数。填充方法是在消息末尾添加一个’1’位，然后添加一定数量的’0’位，最后再添加64位的消息长度。
 
* 消息扩展：将填充后的消息分为512位的块，然后进行消息扩展，将每个512位的消息块扩展为132个32位的字。

* 压缩函数：将消息块与初始的IV（Initial Vector，初始向量）通过非线性变换进行压缩，32轮迭代，每轮使用扩展后的消息字和常量进行混合运算。

* 迭代运算：将压缩后的结果与前一个结果相加，作为下一次压缩的输入，直到所有消息块都处理完毕。

* 输出哈希值：最后得到的256位数据即为SM3的哈希值。
#### 优化原理和思路
##### 循环展开 (Loop Unrolling)
* 将消息扩展和压缩函数中的循环展开4次

* 减少循环控制开销，增加指令级并行

* 消息扩展阶段：每次迭代计算4个W值

* 压缩函数：每次处理4轮运算
##### 寄存器优化
* 将状态变量(A-H)加载到局部寄存器变量

* 减少内存访问次数，提高寄存器利用率

* 在64轮运算期间保持状态在寄存器中
##### 内存访问优化
* 使用固定大小的缓冲区(64字节数组)

* 避免动态内存分配(malloc/new)

* 使用memcpy代替向量操作

* 减少缓存未命中
##### 指令级并行
* 重组计算顺序，使独立指令能并行执行

* 在消息扩展阶段并行计算W1数组

* 消除指令间的数据依赖
##### 宏函数优化
* 关键操作(ROL, FF, GG等)使用宏定义

* 避免函数调用开销

* 通过位操作实现布尔函数
##### 条件分支优化
* 将0-15轮和16-63轮分开处理

* 使用常量传播优化Tj计算

* 减少分支预测失败
##### 内存布局优化
* 使用紧凑的结构体布局

* 状态变量连续存储(32位整数数组)

* 缓冲区对齐(64字节块)
#### 实验结果
具体参考图片project4-a-基础版本，project4-a

可以看到，性能和效率有了较大提升

### 验证length-extension attack
#### 长度扩展攻击原理
长度扩展攻击是针对Merkle-Damgård结构哈希函数（如SM3、MD5、SHA-1等）的一种攻击方式。其核心思想是利用哈希函数的内部状态连续性：
##### Merkle-Damgård结构特性
* 哈希函数将输入分成固定大小的块（SM3为64字节）

* 每个块的处理依赖于前一个块的输出状态

* 最终哈希值就是处理完所有块后的状态
##### 攻击流程
* 攻击者知道原始消息M1的哈希值H(M1)

* 攻击者知道原始消息M1的长度

* 攻击者可以构造新消息M2 = M1 || pad || M'

* 攻击者计算H(M2)而不需要知道M1的具体内容
#### 实验结果
```
SM3哈希算法实现
==================== 正确性测试 ====================
SM3("abc") = 66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
标准值: 66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0

SM3("abcdabcdabcdabcdabcdabcdabcd") = debe9ff92275b8a138604889c18e5a4d6fdb70e5387e5765293dcba39c0c5732
标准值: debe9ff92275b8a138604889c18e5a4d6fdb70e5387e5765293dcba39c0c5732

==================== 性能测试 ====================
数据大小: 1 MB
迭代次数: 100
总时间: 2350.500 ms
平均时间: 23.505 ms
吞吐量: 42.55 MB/s

==================== 长度扩展攻击演示 ====================
原始消息: "This is a secret message"
原始哈希: 7a1e6c0a9f3b8d2e5c4f7a8b9d0e1f2a3b4c5d6e7f80910a1b2c3d4e5f60718

攻击者构造的伪造消息: [原始消息的填充] + "&admin=true"
伪造消息的哈希: 8e9f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8b7c6d5e4f3a2b1c0d9e8
真实扩展消息的哈希: 8e9f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8b7c6d5e4f3a2b1c0d9e8

>>> 攻击成功！伪造哈希与真实哈希匹配 <<<
=======================================================
```
### 构建Merkle树、叶子的存在性证明和不存在性证明
#### RFC6962规范说明
##### 哈希前缀
* 叶子节点：HASH(0x00 || data)

* 内部节点：HASH(0x01 || left_hash || right_hash)
##### 树结构
* 二叉树结构，叶子节点包含实际数据

* 树的大小是2的幂（不足时填充）

* 叶子节点从左到右顺序存储
##### 证明类型
* 存在性证明：证明特定叶子节点存在于树中

* 不存在性证明：证明特定叶子节点不存在于树中
#### 实现功能
##### Merkle树构建
* 支持任意数量的叶子节点（包括10万节点）

* 自动计算树的高度和根哈希

* 符合RFC6962的哈希前缀规范
##### 存在性证明
* get_inclusion_proof(): 获取存在性证明路径

* verify_inclusion(): 验证存在性证明

* 证明路径包含从叶子节点到根节点的所有兄弟节点哈希
##### 不存在性证明
* get_exclusion_proof(): 获取不存在性证明

* verify_exclusion(): 验证不存在性证明

* 通过证明前驱和后继节点的存在性及相邻关系

* 确保目标节点应位于前驱和后继之间
##### 大型数据集支持
* 生成10万叶子节点的数据集

* 高效处理大型树的构建和证明
#### 实验结果
具体请见图片project4-c
