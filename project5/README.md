## SM2的软件实现优化
### SM2的基础实现
#### SM2算法基础
##### 核心数学原理
SM2的安全性依赖于椭圆曲线离散对数问题：已知椭圆曲线点P和Q=kP，求k在计算上不可行。其数学基础包括：

有限域运算：素域Fp上的加法、乘法、逆运算

椭圆曲线方程：标准方程为 ( y^2 = x^3 + ax + b mod p )，推荐参数为256位素数域

点运算：点加（P+Q）、倍点（2P）和标量乘法（kP）构成核心运算
#### SM2算法基础
##### 数字签名流程
###### 签名生成
计算消息哈希值e=HASH(Z_A || M)，Z_A为用户身份标识

生成随机数k∈[1,n-1]，计算点(x1,y1)=kG

r=(e + x1) mod n，若r=0则重新选k

s=((1+d_A)^-1 * (k - r*d_A)) mod n，输出签名(r,s)
###### 验签流程
验证r,s∈[1,n-1]

计算t=(r+s) mod n，点(x1,y1)=sG + tP_A

验证r ≡ (e + x1) mod n
##### 加密与解密流程
###### 加密
生成随机数k，计算C1=kG（椭圆曲线点）

计算S=h*P_B（h为余因子），若S为无穷远点则报错

计算(x2,y2)=kP_B，通过KDF生成密钥t

密文C2=M⊕t，C3=HASH(x2||M||y2)

输出C=C1||C3||C2
###### 解密
验证C1在曲线上，计算S=h*C1

计算(x2,y2)=d_B*C1，生成t=KDF(x2||y2)

解密M’=C2⊕t，验证C3=HASH(x2||M’||y2)
### 代码思路和关键解释
#### SM3哈希算法实现
核心功能：实现国密SM3哈希算法，输出256位哈希值

关键部分：

消息填充：按SM3标准处理任意长度输入

消息扩展：将512位分组扩展为132个32位字

压缩函数：8个状态变量(A-H)的64轮迭代计算

轮函数：使用FF/GG布尔函数和P0/P1置换函数

循环左移：使用位运算实现32位字的循环移位
#### SM2椭圆曲线加密算法
##### 核心功能：实现SM2公钥加密/解密算法

##### 关键部分：

椭圆曲线参数：使用标准sm2p256v1曲线参数

点运算：

_point_add()：实现点加法和点加倍

_scalar_mult()：高效标量乘法（倍点算法）

##### 加密流程：

生成随机数k

计算C1 = k·G

计算S = [h]Pb

计算k·Pb = (x2,y2)

使用KDF生成密钥t

计算C2 = M ⊕ t

计算C3 = Hash(x2||M||y2)

##### 解密流程：

从C1提取点坐标

计算S = [h]C1

计算d·C1 = (x2,y2)

使用KDF生成密钥t

恢复M = C2 ⊕ t

验证C3哈希值

KDF实现：基于SM3的密钥派生函数

##### 测试代码

生成SM2密钥对

加密示例消息"SDUCST"

解密并验证结果
### 关键改进
#### 模块化设计：

SM3和SM2独立实现，可单独使用

清晰的API接口设计

#### 算法优化：

高效标量乘法（倍点算法）

优化的点加/点加倍运算

减少大整数运算开销
### 实验结果
详细请见project5-a.png
