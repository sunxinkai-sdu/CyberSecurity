## SM2的软件实现优化
### SM2的基础实现
#### SM2算法基础
##### 核心数学原理
SM2的安全性依赖于椭圆曲线离散对数问题：已知椭圆曲线点P和Q=kP，求k在计算上不可行。其数学基础包括：

有限域运算：素域Fp上的加法、乘法、逆运算

椭圆曲线方程：标准方程为 ( y^2 = x^3 + ax + b mod p )，推荐参数为256位素数域

点运算：点加（P+Q）、倍点（2P）和标量乘法（kP）构成核心运算
#### SM2算法基础
##### 数字签名流程
###### 签名生成
计算消息哈希值e=HASH(Z_A || M)，Z_A为用户身份标识

生成随机数k∈[1,n-1]，计算点(x1,y1)=kG

r=(e + x1) mod n，若r=0则重新选k

s=((1+d_A)^-1 * (k - r*d_A)) mod n，输出签名(r,s)
###### 验签流程
验证r,s∈[1,n-1]

计算t=(r+s) mod n，点(x1,y1)=sG + tP_A

验证r ≡ (e + x1) mod n
##### 加密与解密流程
###### 加密
生成随机数k，计算C1=kG（椭圆曲线点）

计算S=h*P_B（h为余因子），若S为无穷远点则报错

计算(x2,y2)=kP_B，通过KDF生成密钥t

密文C2=M⊕t，C3=HASH(x2||M||y2)

输出C=C1||C3||C2
###### 解密
验证C1在曲线上，计算S=h*C1

计算(x2,y2)=d_B*C1，生成t=KDF(x2||y2)

解密M’=C2⊕t，验证C3=HASH(x2||M’||y2)
### 代码思路和关键解释
#### SM3哈希算法实现
核心功能：实现国密SM3哈希算法，输出256位哈希值

关键部分：

消息填充：按SM3标准处理任意长度输入

消息扩展：将512位分组扩展为132个32位字

压缩函数：8个状态变量(A-H)的64轮迭代计算

轮函数：使用FF/GG布尔函数和P0/P1置换函数

循环左移：使用位运算实现32位字的循环移位
#### SM2椭圆曲线加密算法
##### 核心功能：实现SM2公钥加密/解密算法

##### 关键部分：

椭圆曲线参数：使用标准sm2p256v1曲线参数

点运算：

_point_add()：实现点加法和点加倍

_scalar_mult()：高效标量乘法（倍点算法）

##### 加密流程：

生成随机数k

计算C1 = k·G

计算S = [h]Pb

计算k·Pb = (x2,y2)

使用KDF生成密钥t

计算C2 = M ⊕ t

计算C3 = Hash(x2||M||y2)

##### 解密流程：

从C1提取点坐标

计算S = [h]C1

计算d·C1 = (x2,y2)

使用KDF生成密钥t

恢复M = C2 ⊕ t

验证C3哈希值

KDF实现：基于SM3的密钥派生函数

##### 测试代码

生成SM2密钥对

加密示例消息"SDUCST"

解密并验证结果
### 关键改进
#### 模块化设计：

SM3和SM2独立实现，可单独使用

清晰的API接口设计

#### 算法优化：

高效标量乘法（倍点算法）

优化的点加/点加倍运算

减少大整数运算开销
### 实验结果
详细请见project5-a.png

### 关于签名算法的误用的poc验证
利用ECDSA签名算法进行相关签名算法误用的poc验证
#### ECDSA签名算法流程
ECDSA签名对(m,r,s)有 $r=(k \cdot G)_{x} \mod n$ , $s=k^{-1}(e+dr) \mod n$ ;计算 $e=Hash(m)$ 
#### 场景1：泄露k导致私钥d泄露
##### 数学推导
攻击者知晓了k（即泄露k），则有

$s=k^{-1}(e+dr) \Rightarrow e+dr=ks \Rightarrow d=r^{-1}(ks-e)$
#### 场景2：重用k导致私钥d泄露
##### 数学推导
假设对两条消息使用用同一k进行签名，即 $s_{1}=k^{-1}(e_{1}+dr)$ , $s_{2}=k^{-1}(e_{2}+dr)$

两式相减得到 $k= \frac {e_{1}-e_{2}}{s_{1}-s_{2}}$ ；代入到原式有 $d= \frac {s_{1}k-e_{1}}{r}$

由此，重用k将使得私钥d泄露
#### 场景3：不同用户使用相同k导致各自私钥泄露
##### 数学推导
与场景2类似

假设用户A和B分别持有私钥d1,d2以及消息m1,m2，我们有签名信息 $s_{1}=k^{-1}(e_{1}+d_{1}r)$ 和 $s_{2}=k^{-1}(e_{2}+d_{2}r)$

两式相减得到 $(s_{1}-s_{2})k=(e_{1}-e_{2})+(d_{1}-d_{2})r$

进而可以得到 $d_{1}-d_{2}=[(s_{1}-s_{2})k-(e_{1}-e_{2})]r^{-1}$

之后根据自身的d就能推测出对方的d，则不同用户使用相同的k会导致各自私钥泄露
#### 混合签名算法导致私钥泄露
##### 数学推导
在ECDSA中有 $s_{E}=k^{-1}(e+dr)$ ,在SCHNORR中有 $s_{S}=k+ed$

由于 $r,s_{E},s_{S}$ 已知，故可以推导出

$e+dr=(s_{S}-d)s_{E} \Rightarrow d(r+s_{E})=s_{S}s_{E}-e \Rightarrow d= \frac {s_{S}s_{E}-e}{r+e_{s}s_{E}}$
### 结果分析
详细请见project5-b.png

