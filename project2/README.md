## 基于数字水印的图片泄露检测
### 实验方法
基于最低有效位(LSB)的图像水印嵌入算法

实现水印提取算法并验证其正确性

测试水印系统对常见图像处理操作的鲁棒性
### 实现原理
#### 水印嵌入原理
LSB(最低有效位)水印技术利用人类视觉系统对图像最低位不敏感的特性，将水印信息嵌入到像素的最低有效位中。具体实现流程如下：
##### 文本转二进制
```
def tobits(text):
    bits = []
    for char in text:
        b = bin(ord(char))[2:].rjust(8, '0')
        bits.extend([int(bit) for bit in b])
    return bits
```
将每个字符转换为8位二进制表示

不足8位在前面补0

返回所有字符连接成的比特序列
##### 添加长度信息
```
length_bits = [int(b) for b in bin(length)[2:].rjust(8, '0')]
full_bits = length_bits + bits
```
在水印比特流前添加8位长度信息

确保提取时能准确知道水印长度
##### 嵌入水印
```
b, g, r = cv2.split(img.copy())
flat = b.flatten()
flat = (flat & 0xFE) | np.array(all_bits, dtype=np.uint8)
```
分离图像蓝色通道（选择蓝色通道因人类视觉对其最不敏感）

使用位操作(AND 0xFE)将最低位清零

将水印比特写入最低位(OR操作)

重组图像通道并保存
#### 水印提取原理
##### 提取LSB比特
```
b = img[:, :, 0].flatten()
bits = [int(bit) for bit in (b & 1)]
```
分离蓝色通道并展平

通过位操作(AND 1)提取所有最低位
##### 解析长度信息
```
length = int(''.join(str(bit) for bit in bits[:8]), 2)
text_bits = bits[8:8+length]
```
提取前8位作为水印长度信息

根据长度提取后续水印比特
##### 比特流转文本
```
for i in range(0, len(bits), 8):
    byte = bits[i:i+8]
    val = int(''.join(str(b) for b in byte), 2)
    word.append(chr(val))
```
每8位一组转换为整数

将整数转换为对应字符

组合所有字符形成原始文本
### 鲁棒性测试实现
#### 翻转测试
实现原理：提取前将图像翻转回原始方向

测试目的：验证水印对几何变换的抵抗能力
#### 平移测试
图像向右平移50像素，向下平移30像素

测试水印对图像位置变化的抵抗能力
#### 截取测试
截取图像中心区域(250×300像素)

测试水印对部分图像缺失的抵抗能力
#### 对比度调整
将图像对比度增加1.5倍

测试水印对颜色调整的抵抗能力
#### 噪声攻击
添加高斯噪声(均值0，标准差25)

模拟传输过程中的随机噪声干扰
### 实验结果
具体请见project2图片

由结果可以看到，我们提取出的文本水印和最初嵌入的是完全一致的，并且翻转后仍能正常提取。

鲁棒性表现：

对翻转、平移等几何变换有良好抵抗

截取测试中因水印嵌入左上角区域而成功

对轻度噪声和对比度调整有抵抗力

