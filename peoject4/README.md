## SM3的软件实现与优化
### 实现和优化SM3算法
#### SM3算法流程
* 消息填充：首先对输入的消息进行填充，使其长度变为512的倍数。填充方法是在消息末尾添加一个’1’位，然后添加一定数量的’0’位，最后再添加64位的消息长度。
 
* 消息扩展：将填充后的消息分为512位的块，然后进行消息扩展，将每个512位的消息块扩展为132个32位的字。

* 压缩函数：将消息块与初始的IV（Initial Vector，初始向量）通过非线性变换进行压缩，32轮迭代，每轮使用扩展后的消息字和常量进行混合运算。

* 迭代运算：将压缩后的结果与前一个结果相加，作为下一次压缩的输入，直到所有消息块都处理完毕。

* 输出哈希值：最后得到的256位数据即为SM3的哈希值。
#### 优化原理和思路
##### 循环展开 (Loop Unrolling)
* 将消息扩展和压缩函数中的循环展开4次

* 减少循环控制开销，增加指令级并行

* 消息扩展阶段：每次迭代计算4个W值

* 压缩函数：每次处理4轮运算
##### 寄存器优化
* 将状态变量(A-H)加载到局部寄存器变量

* 减少内存访问次数，提高寄存器利用率

* 在64轮运算期间保持状态在寄存器中
##### 内存访问优化
* 使用固定大小的缓冲区(64字节数组)

* 避免动态内存分配(malloc/new)

* 使用memcpy代替向量操作

* 减少缓存未命中
##### 指令级并行
* 重组计算顺序，使独立指令能并行执行

* 在消息扩展阶段并行计算W1数组

* 消除指令间的数据依赖
##### 宏函数优化
* 关键操作(ROL, FF, GG等)使用宏定义

* 避免函数调用开销

* 通过位操作实现布尔函数
##### 条件分支优化
* 将0-15轮和16-63轮分开处理

* 使用常量传播优化Tj计算

* 减少分支预测失败
##### 内存布局优化
* 使用紧凑的结构体布局

* 状态变量连续存储(32位整数数组)

* 缓冲区对齐(64字节块)
#### 实验结果
具体参考图片project4-a-基础版本，project4-a

可以看到，性能和效率有了较大提升

### 构建Merkle树、叶子的存在性证明和不存在性证明
#### RFC6962规范说明
##### 哈希前缀
* 叶子节点：HASH(0x00 || data)

* 内部节点：HASH(0x01 || left_hash || right_hash)
##### 树结构
* 二叉树结构，叶子节点包含实际数据

* 树的大小是2的幂（不足时填充）

* 叶子节点从左到右顺序存储
##### 证明类型
* 存在性证明：证明特定叶子节点存在于树中

* 不存在性证明：证明特定叶子节点不存在于树中
#### 实现功能
##### Merkle树构建
* 支持任意数量的叶子节点（包括10万节点）

* 自动计算树的高度和根哈希

* 符合RFC6962的哈希前缀规范
##### 存在性证明
* get_inclusion_proof(): 获取存在性证明路径

* verify_inclusion(): 验证存在性证明

* 证明路径包含从叶子节点到根节点的所有兄弟节点哈希
##### 不存在性证明
* get_exclusion_proof(): 获取不存在性证明

* verify_exclusion(): 验证不存在性证明

* 通过证明前驱和后继节点的存在性及相邻关系

* 确保目标节点应位于前驱和后继之间
##### 大型数据集支持
* 生成10万叶子节点的数据集

* 高效处理大型树的构建和证明
#### 实验结果
